## Problem

> **문제**
  ```
  > 오름차순으로 정렬이 된 두 리스트가 주어지면 두 리스트를 오름차순으로 합쳐 출력하는 프로그램을 작성하시오.

  - 입력설명
    * 첫 번째 줄에 첫 번째 리스트의 크기 N(1 ≤ N ≤ 100)이 주어진다.
    * 두 번째 줄에 N개의 리스트 원소가 오름차순으로 주어진다.
    * 세 번째 줄에 두 번째 리스트의 크기 M(1 ≤ M ≤ 100)이 주어진다.
    * 네 번째 줄에 M개의 리스트 원소가 오름차순으로 주어진다.
    * 각 리스트의 원소는 int형 변수의 크기를 넘지 않는다.

  - 출력설명
    * 오름차순으로 정렬된 리스트를 출력한다.
  ```
  
<br>
<hr>

## Solution

> **입력**
  ```
  3
  1 3 5
  5
  2 3 6 7 9
  ```

<br>
<br>

> **풀이**
  ```python
  import sys
  sys.stdin=open('input.txt', 'rt')

  n = int(input())
  a = list(map(int, input().split()))
  m = int(input())
  b = list(map(int, input().split()))

  p1 = p2 = 0
  c = []

  while p1 < n and p2 < m:
      if a[p1] <= b[p2]:
          c.append(a[p1])
          p1 += 1
      else:
          c.append(b[p2])
          p2 += 1

  if p1 < n:
      c = c + a[p1:]
  if p2 < m:
      c = c + b[p2:]

  for x in c:
      print(x, end=' ')

  """
  출력: 1 2 3 3 5 6 7 9
  """
  ```

<br>
<br>

> **설명**
  ```
  1. 포인트 변수 p1과 p2를 활용하여 각 리스트의 요소값을 비교한 후, 작은 값을 우선적으로 새로운 리스트에 넣어줍니다.
  2. 만약 비교하는 두 수가 같을 경우 p1의 수를 먼저 새로운 리스트에 넣습니다.(이 경우에도 여전히 오름차순 정렬 기준을 만족함)
  3. p1 < n 혹은 p2 < m의 조건을 만족하지 않으면, 반복문은 종료되고 조건에 따라 나머지 리스트의 요소값을 모두 새로운 리스트로 넣어줍니다.
  4. 참고로, 두 리스트를 연산자로 더하여 sort() 메서드를 사용하면 원하는 결과를 얻을 수도 있습니다.
  5. 하지만 sort() 메서드를 사용하면 nlogn번의 데이터 비교가 발생하기 때문에 비효율적인 풀이입니다.
  6. 참고로, 위에서 반복문을 사용한 풀이는 n번의 데이터 비교가 발생하며 이러한 차이는 데이터가 많을수록 커집니다.
  ```